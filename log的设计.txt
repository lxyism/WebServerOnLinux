log的设计仿照了muduo库的设计，但写的没有那么复杂

与Log相关的类包括FileUtil、LogFile、AsyncLogging、LogStream、Logging
其中前4个类都包含了有一个append函数，Log的设计也是主要围绕这个append函数展开的。

FileUtil是最底层的文件类，封装了Log文件的打开、写入并在类析构的时候关闭文件，底层使用了标准IO
，该append函数直接向文件写。
LogFile进一步封装了FileUtil，并设置了一个循环次数，每过这么多次就flush一次
AsyncLogging是核心，它负责启动一个log线程，专门用来将log写入LogFile中，应用了“双缓冲技术”，
其实有4个以上的缓冲区，但思想是一样的。
AsyncLogging负责（定时到或将被填满时）将缓冲区的数据写入到LogFile中。
LogStream主要用来格式化输出，重载了<<运算符，同时也有一个自己的缓冲区，这里的缓冲区的存在是为了
缓存一行，把多个<<的结果连成一片。
Logging是对外接口，Logging类内含了一个LogStream对象，主要是为了每次打印log的时候，在log之前和之后
加上固定的格式化的信息，比如打印log的行文件名等信息。

异步日志类：
* 对于一般的日志类的实现，（1）、重载<<格式化输出； （2）日志级别处理； （3）缓冲区设置
* 为了提高效率并防止阻塞业务线程，用一个背景线程负责收集日志消息，并写入日志文件，其他业务只管往这个日志
线程发送日志消息，这称为异步日志。基本实现仍然是生产者（业务程序）与消费者（日志程序）和缓冲区，但是这样简单
模型会造成写文件操作比较频繁，因为每一次signal我们就需要写操作，将消息全部写入文件，效率较低。muduo使用“多
缓冲机制”，即multiple buffing，使用多个缓冲区，当一块缓冲区写满或者事件超过signal；如果发送消息堆积，会丢弃
只剩2块内存。另外使用swap公共缓冲区来避免竞争，一次获得所有的消息并写入文件。


